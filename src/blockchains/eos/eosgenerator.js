(function(){function eosgenerator(it
/*``*/) {
var out='#include <string>\n#include <eosiolib/eosio.hpp>\n#include <eosiolib/action.hpp>\n#include <eosiolib/singleton.hpp>\n#include <eosiolib/time.hpp>\n#include <eosiolib/system.h>\n\nusing namespace eosio;\nusing std::string;\ntemplate <uint64_t OraclizeName, uint32_t BestBeforeOffset, uint32_t UpdateOffset, typename T>\nclass oraclized\n{\n  struct data\n  {\n    uint32_t best_before;\n    uint32_t update_after;\n    T value;\n\n    EOSLIB_SERIALIZE(data, (best_before)(update_after)(value))\n  };\n\n  constexpr static uint64_t pk_value = OraclizeName;\n  struct row\n  {\n    data value;\n\n    uint64_t primary_key() const { return pk_value; }\n\n    EOSLIB_SERIALIZE(row, (value))\n  };\n\n  typedef eosio::multi_index<OraclizeName, row> table;\n\nprivate:\n  table _t;\n\npublic:\n  oraclized(account_name code, scope_name scope) : _t(code, scope) {}\n\n  bool exists()\n  {\n    return _t.find(pk_value) != _t.end();\n  }\n\n  bool fresh()\n  {\n    return exists() && get().best_before > now();\n  }\n\n  bool require_update()\n  {\n    return exists() && get().update_after < now();\n  }\n\n  T value()\n  {\n    return get().value;\n  }\n\n  data get()\n  {\n    auto itr = _t.find(pk_value);\n    eosio_assert(itr != _t.end(), "singleton does not exist");\n    return itr->value;\n  }\n\n  data get_or_default(const T &def = T())\n  {\n    auto itr = _t.find(pk_value);\n    return itr != _t.end() ? itr->value : def;\n  }\n\n  data get_or_create(account_name bill_to_account, const T &def = T())\n  {\n    auto itr = _t.find(pk_value);\n    return itr != _t.end() ? itr->value\n                           : _t.emplace(bill_to_account, [&](row &r) { r.value = data{}; });\n  }\n\n  void set(const T &value, account_name bill_to_account)\n  {\n    auto itr = _t.find(pk_value);\n    if (itr != _t.end())\n    {\n      _t.modify(itr, bill_to_account, [&](row &r) { r.value = data{now() + BestBeforeOffset, now() + UpdateOffset, value}; });\n    }\n    else\n    {\n      _t.emplace(bill_to_account, [&](row &r) { r.value = data{now() + BestBeforeOffset, now() + UpdateOffset, value}; });\n    }\n  }\n\n  void remove()\n  {\n    auto itr = _t.find(pk_value);\n    if (itr != _t.end())\n    {\n      _t.erase(itr);\n    }\n  }\n};\n\n// @abi table args i64\nstruct request_args\n{\n  bytes schema;\n  bytes args;\n};\n// carbon-copy call structure\nstruct push_data\n{\n  account_name oracle;\n  account_name contract;\n  string task;\n  string memo;\n  bytes data;\n\n  EOSLIB_SERIALIZE(push_data, (oracle)(contract)(task)(memo)(data))\n};\n\n';var arr1=it.customs;if(arr1){var c,i1=-1,l1=arr1.length-1;while(i1<l1){c=arr1[i1+=1];out+='struct '+( c.name)+'\n{\n  ';var arr2=c.fields;if(arr2){var f,i2=-1,l2=arr2.length-1;while(i2<l2){f=arr2[i2+=1];out+=''+( f.type )+' '+( f.name )+';\n  ';} } out+='\n\n  EOSLIB_SERIALIZE('+( c.name )+', ';var arr3=c.fields;if(arr3){var f,i3=-1,l3=arr3.length-1;while(i3<l3){f=arr3[i3+=1];out+='('+( f.name )+')';} } out+=')\n};\n';} } out+='\n';var arr4=it.providers;if(arr4){var p,i4=-1,l4=arr4.length-1;while(i4<l4){p=arr4[i4+=1];out+='\n// @abi table '+( p.alias)+' i64\nstruct '+( p.alias)+'\n{\n  uint32_t best_before;\n  uint32_t update_after;\n  '+( p.type )+' value;\n\n  EOSLIB_SERIALIZE('+( p.alias)+', (best_before)(update_after)(value))\n};\n';} } out+='\n';var arr5=it.providers;if(arr5){var p,i5=-1,l5=arr5.length-1;while(i5<l5){p=arr5[i5+=1];out+='\ntypedef oraclized<N('+( p.alias )+'), '+( p.bestBefore )+', '+( p.updateAfter )+', '+( p.type )+'> '+( p.name )+'_data;';} } out+='\n\ntypedef singleton<N(master), account_name> account_master;\n\nclass YOUR_CONTRACT_NAME : public eosio::contract\n{\nprivate:\n';var arr6=it.providers;if(arr6){var p,i6=-1,l6=arr6.length-1;while(i6<l6){p=arr6[i6+=1];out+='\n  '+( p.name )+'_data '+( p.name )+';';} } out+='\n\n  account_name known_master;\n\npublic:\n  using contract::contract;\n\n  YOUR_CONTRACT_NAME(account_name s) : contract(s)';var arr7=it.providers;if(arr7){var p,i7=-1,l7=arr7.length-1;while(i7<l7){p=arr7[i7+=1];out+=', '+( p.name )+'(_self, _self)';} } out+='\n  {\n    known_master = account_master(_self, _self).get_or_create(_self, N(undefined));\n  }\n\n  void receive(account_name self, account_name code)\n  {\n    eosio_assert(known_master != N(undefined), "Contract didn\'t setupped yet");\n    eosio_assert(code == known_master, "Unkown master contract");\n    auto payload = unpack_action_data<push_data>();\n\n    ';var arr8=it.providers;if(arr8){var p,i8=-1,l8=arr8.length-1;while(i8<l8){p=arr8[i8+=1];out+='if (strcmp(payload.task.c_str(), "'+( p.id )+'") == 0)\n    {\n      '+( p.type )+' p = unpack<'+( p.type )+'>(payload.data);\n      '+( p.name )+'.set(p, _self);\n      return;\n    }\n    ';} } out+='\n\n    eosio_assert(true, "Unknown task received");\n  }\n\n  // @abi action\n  void setup(account_name master)\n  {\n    require_auth(_self);\n    account_master(_self, _self).set(master, _self);\n    ';var arr9=it.providers;if(arr9){var p,i9=-1,l9=arr9.length-1;while(i9<l9){p=arr9[i9+=1];out+='ask_data(_self, master, "'+( p.id )+'", '+( p.updateAfter )+'u,\n             string(),\n             ';if(p.args.length){out+='pack(request_args{\n                 // data schema\n                 bytes{';var arr10=p.args;if(arr10){var a,i=-1,l10=arr10.length-1;while(i<l10){a=arr10[i+=1];if(i){out+=', ';}out+=''+( a.type );} } out+='},\n                 // binary data\n                 pack(\n                   std::make_tuple(';var arr11=p.args;if(arr11){var a,i=-1,l11=arr11.length-1;while(i<l11){a=arr11[i+=1];if(i){out+=', ';}out+=''+( a.default );} } out+=')\n                 )})';}else if(true){out+='pack(request_args{bytes{}, bytes{}})';}out+=');\n';} } out+='\n  }\n\n  void ask_data(account_name administrator,\n                account_name registry,\n                string data,\n                uint32_t update_each,\n                string memo,\n                bytes args)\n  {\n    action(permission_level{administrator, N(active)},\n           registry, N(ask),\n           std::make_tuple(administrator, _self, data, update_each, memo, args))\n        .send();\n  }\n};\n\n\nextern "C" void apply(uint64_t receiver, uint64_t code, uint64_t action)\n{\n  uint64_t self = receiver;\n  if (action == N(onerror))\n  {\n    /* onerror is only valid if it is for the "eosio" code account and authorized by "eosio"\'s "active permission */\n    eosio_assert(code == N(eosio), "onerror action\'s are only valid from the \\"eosio\\" system account");\n  }\n\n  YOUR_CONTRACT_NAME thiscontract(self);\n\n  if (code == self || action == N(onerror))\n  {\n    switch (action)\n    {\n      // NB: Add custom method in bracets after (setup) to use them as endpoints\n      EOSIO_API(YOUR_CONTRACT_NAME, (setup))\n    }\n  }\n\n  if (code != N(self) && action == N(push))\n  {\n    thiscontract.receive(receiver, code);\n  }\n}';return out;
}var itself=eosgenerator, _encodeHTML=(function (doNotSkipEncoded) {
		var encodeHTMLRules = { "&": "&#38;", "<": "&#60;", ">": "&#62;", '"': "&#34;", "'": "&#39;", "/": "&#47;" },
			matchHTML = doNotSkipEncoded ? /[&<>"'\/]/g : /&(?!#?\w+;)|<|>|"|'|\//g;
		return function(code) {
			return code ? code.toString().replace(matchHTML, function(m) {return encodeHTMLRules[m] || m;}) : "";
		};
	}());if(typeof module!=='undefined' && module.exports) module.exports=itself;else if(typeof define==='function')define(function(){return itself;});else {window.render=window.render||{};window.render['eosgenerator']=itself;}}());